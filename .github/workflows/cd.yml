name: CD - Deploy Iris API to GKE

on:
  push:
    branches: [ main ] # This pipeline runs on merge/push to main

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: asia-south1 
  GKE_CLUSTER_NAME: iris-cluster 
  GAR_REPO_NAME: iris-api-repo 
  DEPLOYMENT_NAME: iris-api-deployment 
  IMAGE_NAME: iris-api

jobs:
  build-and-push-image:
    name: Build and Push to Artifact Registry
    runs-on: ubuntu-latest

    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Authenticate to GCP
      id: auth
      uses: 'google-github-actions/auth@v1'
      with:
        workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
        service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

    - name: Configure Docker
      run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

    - name: Build Docker Image
      run: |
        docker build -t $IMAGE_NAME -f Dockerfile .
        
    - name: Tag and Push Docker Image
      run: |
        # Create a unique tag using the short Git commit SHA
        export IMAGE_TAG=${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPO_NAME }}/$IMAGE_NAME:${{ github.sha }}
        docker tag $IMAGE_NAME $IMAGE_TAG
        docker push $IMAGE_TAG
        
    - name: 'Store image URI for deploy'
      # Save the full image URI as an environment variable for the next job
      run: echo "IMAGE_URI=$IMAGE_TAG" >> $GITHUB_ENV

  deploy-to-gke:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    needs: build-and-push-image # This job waits for the first job to finish

    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Authenticate to GCP
      id: auth
      uses: 'google-github-actions/auth@v1'
      with:
        workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
        service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

    - name: Get GKE credentials
      # This configures 'kubectl' inside the GitHub runner to talk to your cluster
      run: gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_NAME }} --region ${{ env.GCP_REGION }}

    - name: Set production values in k8s manifest
      # This step replaces the placeholders in your deployment.yaml file
      run: |
        sed -i 's|YOUR_MLFLOW_SERVER_IP|${{ secrets.MLFLOW_SERVER_IP }}|g' k8s/deployment.yaml
        sed -i 's|YOUR_PROJECT_ID|${{ env.GCP_PROJECT_ID }}|g' k8s/deployment.yaml

    - name: Deploy to GKE
      run: |
        # Apply the service first (LoadBalancer, etc.)
        kubectl apply -f k8s/deployment.yaml
        
        # Now, update the deployment to use the new image we just built
        # This triggers a graceful rolling update of your Pods
        kubectl set image deployment/${{ env.DEPLOYMENT_NAME }} api-container=${{ env.IMAGE_URI }}
